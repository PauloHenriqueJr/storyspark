# Regras de IA para o App StorySpark

## Tech Stack

- **React 18 com TypeScript**: Framework principal para construção de interfaces reativas e tipadas, com uso de hooks nativos (useState, useEffect) para gerenciamento de estado local e global via Context.
- **Vite**: Ferramenta de build rápida para desenvolvimento e produção, com suporte a hot module replacement (HMR), lazy loading via React.lazy e Suspense para otimização de performance em páginas como Dashboard e Composer.
- **Supabase**: Plataforma backend como serviço para autenticação (OAuth, email/password), banco de dados PostgreSQL em tempo real, storage e funções edge. Implementado como singleton em src/lib/supabase.ts com helpers para auth (signIn, signUp, etc.).
- **Tailwind CSS com shadcn/ui**: Framework de CSS utility-first integrado com PostCSS para estilização responsiva. shadcn/ui fornece componentes baseados em Radix UI (Card, Button, Dialog, etc.), com classes gerenciadas via função cn em utils.ts usando clsx e tailwind-merge.
- **React Router DOM v6**: Gerenciamento de rotas com ProtectedRoute para autenticação, lazy loading de páginas em App.tsx, e suporte a navegação programática (useNavigate) em componentes como HookCard.
- **Zod e React Hook Form**: Validação de formulários com Zod schemas integrados ao React Hook Form para campos como login, cadastro e configurações, garantindo tipagem e sanitização de inputs.
- **TanStack React Query (v5)**: Gerenciamento de dados assíncronos e caching para queries/mutações, usado em hooks como useAnalytics para fetch de stats, uso e performance de conteúdo.
- **Framer Motion e Lucide React**: Animações suaves com Framer Motion para transições em UI (ex: hover effects em cards), e ícones vetoriais do Lucide para elementos como Heart e Zap em HookCard.
- **Sonner e Recharts**: Notificações toast com Sonner para feedback de usuário (ex: "Hook enviado para o Composer"), e gráficos com Recharts para visualização de analytics em páginas como Analytics.
- **Playwright e Vitest**: Testes end-to-end com Playwright para fluxos de auth e UI, e unitários com Vitest para componentes e hooks, configurados via package.json scripts.

## Regras de Uso de Bibliotecas

- **React e Componentes**: Use React para todos os componentes de UI em src/components/. Mantenha componentes presentacionais (ex: HookCard com Card de shadcn/ui) separados de lógicos em hooks (ex: useAnalytics). Empregue lazy loading com React.lazy em App.tsx para páginas pesadas como Calendar e AdminDashboard. Evite bibliotecas de UI completas como Material-UI; priorize shadcn/ui para consistência com Tailwind.
- **TypeScript**: Defina interfaces em src/types/ para props (ex: HookCardProps), respostas de API (ex: AnalyticsStats) e dados de auth (User, AuthError). Use tipagem estrita em hooks e services, com generics para funções como fetchData em useAnalytics.
- **Supabase Client**: Centralize todas as interações backend em src/lib/supabase.ts como singleton para evitar múltiplas instâncias. Use authHelpers para signIn/signUp/OAuth (Google), e queries realtime para dados dinâmicos. Em services como analyticsService, integre Supabase para fetch de stats e tracking de eventos. Não use alternativas como Firebase; Supabase é obrigatório para auth, DB e storage.
- **Estilos e Tailwind/shadcn/ui**: Aplique Tailwind classes diretamente em componentes (ex: bg-gradient-to-r em Botões). Use cn() de utils.ts para merging condicional de classes. Configure temas em tailwind.config.ts e use componentes Radix via shadcn (ex: Card, Button, Badge em HookCard). Evite CSS global customizado; use animações Tailwind ou Framer Motion para effects como hover:scale-[1.02].
- **Gerenciamento de Estado e Dados**: Para estado local, use useState/useEffect (ex: isFavorite em HookCard). Para global, React Context (ex: useWorkspace). Use TanStack Query para queries assíncronas em hooks (ex: getUsageData em useAnalytics). Evite Redux; priorize Query para caching e refetch automático.
- **Requisições HTTP e Integrações**: Use Supabase client para todas as operações DB/auth. Para APIs externas (ex: Google OAuth), integre via Supabase. Em hooks como useAnalytics, use Promise.all para fetches paralelos. Prefira fetch nativo ou Supabase sobre Axios, exceto se necessário para interceptors.
- **Formulários e Validação**: Integre React Hook Form com Zod para todos os forms (ex: SignInData). Defina schemas Zod em services ou hooks para validação server-side compatible. Use resolvers como @hookform/resolvers/zod para integração seamless.
- **Navegação e Rotas**: Use React Router para todas as rotas em App.tsx, com ProtectedRoute para guards de auth/admin. Empregue useNavigate para redirecionamentos programáticos (ex: navigate para /composer em HookCard). Suporte lazy loading com Suspense para performance.
- **Animações e UX**: Use Framer Motion para transições complexas (ex: animate-fade-in em cards). Integre Sonner para toasts informativos (ex: toast.success com description). Use Lucide para ícones consistentes. Evite bibliotecas pesadas como GSAP; Tailwind transitions para simples hovers.
- **Analytics e Tracking**: Implemente tracking em hooks/services (ex: trackEvent em useAnalytics com gtag). Use Recharts para visualizações (ex: gráficos de revenueData). Integre Supabase para storage de eventos. Para PWA, use vite-plugin-pwa; evite analytics third-party como Google Analytics se Supabase Edge Functions sufficirem.
- **Testes e Scripts**: Use Playwright para E2E (ex: fluxos de auth em e2e/). Configure Vitest para unit tests em __tests__/. Scripts em package.json para lint/type-check/build. Para seeding, use Supabase migrations e scripts como waitlist_insert.mjs.
- **Utilitários e Helpers**: Crie funções em src/lib/ (ex: supabase helpers) e src/utils/ (ex: cn para classes). Evite Lodash/date-fns exceto para parsing específico (ex: date-fns em calendários). Implemente mocks em lib/mockData.ts para dev.
- **Segurança e Config**: Nunca exponha chaves em código; use .env.local para VITE_SUPABASE_URL/KEY. Implemente RLS no Supabase. Para uploads, use react-dropzone com Supabase storage. Monitore erros com console.log em dev, mas evite em prod.